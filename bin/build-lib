#!/usr/bin/env bash
# @file lib-build
# @brief A library for generating build-depends for a task.

# region #! globals

#! constraints
BREQ_MAX_DEPTH=17

#! build-reqs dir
BREQ_DIR="${PROJ_DIR}/.build-reqs"

# endregion

# region #! include

. ./bin/bspec-lib
. ./bin/debver-lib
. ./bin/test-lib

# endregion

# region #! breq strings funcs

# pack depends to spaceless string: breqPackString <string>
breqPackString() {
  local str="$1"
  # str=$(tr -cd '[:print:]' <<< "$str")
  str="${str//' '/'&'}"
  echo "$str"
}

# unpack spaceless string: breqUnpackString <string>
breqUnpackString() {
  local str="$1"
  str="${str//'&'/' '}"
  echo "$str"
}

# unpack and call taskParseBR: breqParsePacked <string>
breqParsePacked() {
  local unpacked=$(breqUnpackString "$1")
  unpacked=$(sed 's/\(.*\)\:any$/\1/' <<< "$unpacked") # fixme: package:any hack
  local breqs=$(taskParseBR "$unpacked")
  echo "${breqs[*]}"
}

# endregion

# region #! version funcs

# check version reqs and return index of suitable: breqWhichVersion <cond> <@versions>
# @description Function to find suitable package from available packages accroding dependency requrenment string.
#
# @example
#    $(breqWhichVersion <req> <packages>)"
#
# @arg `req` requrenment string like ">= 2.4 2.31-13+deb11u6".
# @arg packages array of available in [bspec](./lib-bspec) format.
#
# @stdout index of suitable package
#
# @exitcode 0 on success
# @exitcode 1 on failure.
breqWhichVersion() {
  local cond="$1"
  shift
  local avail=($@)

  testAddToVersionSamples $cond $avail # generate version samples

  for ((idx=0; idx < ${#avail[@]}; ++idx)); do
    local matched=$(dverMatch "$cond" "${avail[$idx]}")
    [[ -n "$matched" ]] && break
  done

  if [[ -n $matched ]]; then
    echo $idx
    return 0
  else
    return 1
  fi
}

# endregion

# region #! node funcs

# region #! log funcs

# fixme: breqPrintMsg is ugly - rewrite
# print node tag: breqPrintName <level> <@bnames> <message>"
breqPrintName() {
  local lvl="$1"
  IFS="/" read -ra pth <<< "$2"

  if [[ $lvl -eq 1 ]]; then
    (printf "${COLOR_OFF}{${pth[0]}${COLOR_GREEN} ${pth[1]}${COLOR_OFF}} $3") >&2
    return
  fi

  local len=$(( ${#pth[@]} - 1))
  local head="${pth[@]:0:$len}"
  for h in ${pth[@]:0:$len}; do
    head+="$h "
  done
  last="${pth[-1]}"
  (printf "${COLOR_OFF}{${COLOR_GREEN}$last${COLOR_OFF}} $3") >&2

  return
}

# print status message: breqPrintStatus <level> <status> <message>
breqPrintStatus() {
  local lvl=$1
  shift
  local tail
  [[ $lvl -eq 1 ]] && nl="\n"
  case "$1" in
       'ok') [[ $lvl -eq 1 ]] && (printf "[${COLOR_GREEN}OK${COLOR_OFF}]$nl") >&2 || (printf "") >&2 ;;
    'nodep') (printf "[${COLOR_YELLOW}!dep${COLOR_OFF}] ") >&2 ;;
     'have') (printf "[${COLOR_YELLOW}+$2${COLOR_OFF}] ") >&2 ;;
     'note') (printf "[${COLOR_YELLOW}$2${COLOR_OFF}]$nl") >&2 ;;
      'err') (printf "[${COLOR_RED}$2${COLOR_OFF}]$nl") >&2 ;;
          *) (printf "[${COLOR_RED}$1:$2${COLOR_OFF}]$nl") >&2 ;;
  esac
}

# endregion

# region #! node funcs

# @description Function to add node to build-depens tree. Reqursive.
#
# @example
#    $(breqAddNode <level> <bspec> <@parents>)"
#
# @arg level numeric target level of build-depens tree.
# @arg bspec build-dependency in `bspec` format.
# @arg parents parents array of build-dependency upto root node.
#
# @stdout last processed (failed) package in bspec format (@see bspec).
#
# @exitcode 0 on success.
# @exitcode 1 on failure.
#
# @see bspec
breqAddNode() {
  local level=$(( $1 + 1 ))
  local bspec="$2"
  shift; shift

  local bname=$(bspecName $bspec)
  local bver=$(bspecVersionHR $bspec)

  local pa=($@) #? parents array
  local parent="${pa[-1]}" #? prev node
  local pinfo #? parents str separated by "/"
  local req_dir="$BREQ_DIR" #? path to store node info

  for p in "${pa[@]}"; do
    pinfo+="/$p"
    req_dir+="/$p"
  done
  req_dir+="/$bname"
  pinfo="${pinfo:1}"

  [[ -d "$req_dir" ]] || mkdir "$req_dir"
  echo "$bname" > "$req_dir/.name"
  echo "$bver" > "$req_dir/.version"
  echo "$parent" > "$req_dir/.parent"

  breqPrintName $level "$pinfo/$bname"

  local str="$(dockerAptCache "$bname")"

  #? gathering depends
  local dstr=$(breqPackString "$(sed -n 's/^Depends: \(.*\)$/\1/pg' <<< $str)")
  local da
  for line in ${dstr//"\n"/ }; do
    line=$(tr -cd '[:print:]' <<< "$line")
    da+=($line)
  done

  if [[ ${#da[@]} -eq 0 ]]; then
    breqPrintStatus $level "nodep"
    [[ $level -eq 1 ]] && breqPrintStatus $level "ok" #? nodeps is ok - inform caller
    #? nodeps is ok - inform caller
    echo "$bspec"
    return 0
  fi

  #? avaible versions
  local vstr=$(sed -n 's/^Version: \(.*\)$/\1/1p' <<< "$str")
  local va
  for line in ${vstr//"\n"/ }; do
    line=$(tr -cd '[:print:]' <<< $line)
    va+=($line)
  done

  #? which version is needed
  local idx=0
  if [[ -n $bver ]] && [[ $bname != "dh-autoreconf" ]]; then # fixme: dh-autoreconf breaks all
    if [[ $bver != '<!nocheck>' ]] && [[ $bver != '[linux-any]' ]]; then # fixme: add propper parsing for: <!nocheck> [linux-any]
      idx=$(breqWhichVersion "$bver" "${va[@]}")
      if [[ $? -gt 0 ]]; then #! nover isn't good - lets caller decide
        breqPrintStatus $level "err" "!ver"
        echo "$bspec"
        return 1
      fi
    fi
  fi

  #? this is our set
  local bdeps="${da[$idx]}"

  #? dive in, god save our souls
  local retcode last_package
  for curset_packed in "${bdeps[@]}"; do
    pa+=("$bname")
    local curset=$(breqParsePacked $curset_packed)
    for bi in ${curset[@]} ; do
      local seen_before=$(grep -Fxc "$(bspecName $bi)" "$BREQ_DIR/$task/.flatten")
      if [[ seen_before -gt 0 ]]; then
        breqPrintStatus $level "have" "$(bspecName $bi)"
      else
        echo $(bspecName $bi) >> "$BREQ_DIR/$task/.flatten"
        echo -n '-> ' >&2 #? dive deep
        last_package=$(breqAddNode $level "$bi" "${pa[@]}")
        retcode=$?
        if [[ $retcode -gt 0 ]]; then
          [[ $level -eq 1 ]] && breqPrintStatus $level "err" "!fail"  # fixme: on top level
          echo "$last_package"
          return $retcode #? bash specific: return just exit for, but assuming normal return for readability
        fi
      fi
    done
  done

  [[ $level -eq 1 ]] && [[ $retcode -eq 0 ]] && breqPrintStatus $level "ok"

  echo "$last_package"
  return $retcode
}

# endregion

# region #! build functions

# init build process
buildInit() {
  # info buildInit "=== test mode ==="
  guestClearFHS # fixme: test
  guestCreateFHS # fixme: test
}

# build task: buildTask <task>
buildTask() {
  local task=$1 bspecs
  taskInit $task
  bspecs=$(taskReqs $task)

  local retcode last_package
  for bs in ${bspecs[@]}; do
    # last_package=$(breqAddRoot "$task" "$bs")
    last_package=$(breqAddNode 0 "$bs" "$task")
    retcode=$?
    [[ $retcode -gt 0 ]] && error 1 EDEPEND "failed to get depended package: $last_package"
    # break # fixme: test
  done
}

# build all tasks: buildAll
buildAll() {
  buildInit
  for task in $(taskList); do
    buildTask $task
    break # fixme: test
  done
}

# endregion

