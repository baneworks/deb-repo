# region #! include

. ./bin/bspec-lib

# endregion

# region #!task funcs

# return task list from taskfile
taskList() {
  echo $(cat $TASK_FILE | tr "\n" ' ')
}

# todo: rewrite & add abitilty to change working mode [docker | local]
# make task dir: taskMakeDir <task>
taskMakeFHS() {
  local btree=$(tagValue "btree")"/$1"
  local bindir=$(tagValue "dbin")"/$1"
  local srcdir=$(tagValue "dsrc")"/$1"
  local tmpdir=$(tagValue "tmp")"/$1"
  dockerExec mkdir {"$btree",$bindir,"$srcdir","$tmpdir"}
  # [[ -d "$btree" ]] && rm -rf "$btree" # fixme: testing
  mkdir -p "$btree" # fixme: a hack
}

# todo: rewrite & add abitilty to change working mode [docker | local]
# purge all from task dir: taskClear <task>
taskClearFHS() {
  local btree=$(tagValue "btree")"/$1"
  local srcdir=$(tagValue "dsrc")"/$1"
  local bindir=$(tagValue "dbin")"/$1"
  local tmpdir=$(tagValue "tmp")"/$1"
  # dockerExec rm -rf {"$btree","$srcdir","$bindir","$tmpdir"} # fixme: test
  dockerExec rm -rf {"$btree","$bindir","$tmpdir"}
  # [[ -d "$btree" ]] && rm -rf "$btree" # fixme: testing
}

# todo: refactor
# prepare for task: taskInit <task>
taskInit() {
  local task="$1"

  wdir=$(tagDir "dsrc")"/$1"
  if [ -d $(guestCreateFHS "dbin" $task) ] ||
     [ -d $(guestCreateFHS "dsrc" $task) ] ||
     [ -d $(guestCreateFHS  "tmp" $task) ]
  then
    # info $task "=== in test mode ==="
    taskClearFHS $task # fixme: testing
  fi

  info $task "dirs ..."
  taskMakeFHS $task # fixme: testing
  [[ -f "$BREQ_DIR/$task/.flatten" ]] && rm -f "$BREQ_DIR/$task/.flatten"
  touch "$BREQ_DIR/$task/.flatten"
  info $task "sources ..."
  [[ $(dockerAptSources $task) -eq 0 ]] || error -1 $task "apt-get source failed!" # fixme: testing
}

# get task dcs filename: taskDsc <task>
taskDsc () {
  local dsc=$(ls $(dockerRelativePath "dsrc" "$task/*.dsc"))
  local task=$1
  [ $(echo $dsc | wc -l) -eq 1 ] || error 1 NODSC "messed up with DSC file [$task]"
  echo "$dsc"
}

# parse Build-Depends and return array: taskParseBR <br_string>
taskParseBR() { # fixme: refactor taskParseBR
  local str="$1"
  str=$(tr -cd '[:print:]' <<< $str)

  str=$(sed 's/ |/,/g' <<< $str) # fixme: alternate depends (x | y) not supported yet, installing both
  str=${str//', '/'/'}
  str=${str//' '/'&'}
  str=$(sed 's/^\&//g' <<< "$str")
  str=$(sed 's/\&$//g' <<< "$str")
  str=$(sed 's/\([>=]\)\&/\1/g' <<< "$str")             #? like (>= 10.1)
  str=$(sed 's/>>/>/g' <<< "$str")                      #? convert things like (>> 10.1) (> 10.1)
  str=$(sed 's/<<&/</g' <<< "$str")                     #? convert things like (<< 10.1) (< 10.1)
  str=$(sed 's/\&\(\[.*\]\)/\&(\1)/g' <<< "$str")       #? like [linux-any]
  str=$(sed 's/\&\(<!nocheck>\)/\&(\1)/g' <<< "$str")   #? like <!no-check>
  str=$(sed 's/\(:any\/\)/\//g' <<< "$str")             #? like :any

  local bspecs
  for s in ${str//'/'/ }; do
    local n=$(sed 's/\(.*\)\s(\(.*\))/\1/g' <<<${s//'&'/ })
    local v=$(sed -n 's/\(.*\)\s(\(.*\))/\2/gp' <<<${s//'&'/ })
    bspecs+=("$n/$v")
  done

  echo "${bspecs[*]}"
}

# parse task dcs and return breqs array: taskReqs <task>
taskReqs() {
  local task=$1

  info $task "build-reqs ..."

  local dsc=$(taskDsc $task)
  local bspecs=($(taskParseBR "$(cat $dsc | sed -n 's/Build-Depends:\(.*\)/\1/p')"))

  if [ -d $BREQ_DIR/$task ]; then
    rm -rf $BREQ_DIR/$task/*
  else
    mkdir $BREQ_DIR/$task
  fi

  echo "${bspecs[*]}"
}

# endregion